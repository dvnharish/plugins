import { ScanResult, Issue } from '@devguard/shared';
import * as fs from 'fs';
import * as path from 'path';

export class ReportGenerator {
    async generateReport(scanResult: ScanResult, format: string, outputFile: string): Promise<void> {
        switch (format.toLowerCase()) {
            case 'markdown':
            case 'md':
                await this.generateMarkdownReport(scanResult, outputFile);
                break;
            case 'sarif':
                await this.generateSarifReport(scanResult, outputFile);
                break;
            case 'json':
                await this.generateJsonReport(scanResult, outputFile);
                break;
            default:
                throw new Error(`Unsupported output format: ${format}`);
        }
    }

    private async generateMarkdownReport(scanResult: ScanResult, outputFile: string): Promise<void> {
        const { issues, score, timestamp, projectPath } = scanResult;
        
        // Group issues by category and severity
        const issuesByCategory = this.groupIssuesByCategory(issues);
        const severityCounts = this.getSeverityCounts(issues);
        
        let markdown = `# üìä DevGuard CLI Report

**Project:** ${path.basename(projectPath)}  
**Scan Date:** ${timestamp.toLocaleString()}  
**Production Readiness Score:** ${score}/100  

## üìà Summary

${this.getScoreDescription(score)}

**Issues Found:** ${issues.length}  
üî¥ ${severityCounts.critical} Critical  
üü† ${severityCounts.high} High  
üü° ${severityCounts.medium} Medium  
üîµ ${severityCounts.low} Low  
‚ö™ ${severityCounts.info} Info  

---

`;

        // Add issues by category
        for (const [category, categoryIssues] of issuesByCategory) {
            if (categoryIssues.length === 0) continue;
            
            const categoryIcon = this.getCategoryIcon(category);
            markdown += `## ${categoryIcon} ${this.capitalize(category)}\n\n`;
            
            // Sort by severity
            const sortedIssues = categoryIssues.sort((a, b) => this.getSeverityWeight(b.severity) - this.getSeverityWeight(a.severity));
            
            for (const issue of sortedIssues) {
                const severityIcon = this.getSeverityIcon(issue.severity);
                const fileName = path.basename(issue.file);
                markdown += `- ${severityIcon} **${issue.rule}** ‚Äì ${fileName}:${issue.line}\n`;
                markdown += `  ${issue.message}\n\n`;
            }
        }

        // Add scanner results
        markdown += `## üîß Scanner Results\n\n`;
        for (const scannerResult of scanResult.scannerResults) {
            const status = scannerResult.success ? '‚úÖ' : '‚ùå';
            const duration = (scannerResult.duration / 1000).toFixed(2);
            markdown += `- ${status} **${scannerResult.scanner}** (${duration}s) - ${scannerResult.issues.length} issues\n`;
            if (!scannerResult.success && scannerResult.error) {
                markdown += `  Error: ${scannerResult.error}\n`;
            }
        }

        markdown += `\n---\n\n*Generated by DevGuard CLI v1.0.0*\n`;
        
        fs.writeFileSync(outputFile, markdown);
    }

    private async generateSarifReport(scanResult: ScanResult, outputFile: string): Promise<void> {
        const { issues, projectPath } = scanResult;
        
        const sarif = {
            version: "2.1.0",
            $schema: "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
            runs: [
                {
                    tool: {
                        driver: {
                            name: "DevGuard CLI",
                            version: "1.0.0",
                            informationUri: "https://github.com/your-org/devguard",
                            rules: this.generateSarifRules(issues)
                        }
                    },
                    results: issues.map(issue => ({
                        ruleId: issue.rule,
                        level: this.mapSeverityToSarifLevel(issue.severity),
                        message: {
                            text: issue.message
                        },
                        locations: [
                            {
                                physicalLocation: {
                                    artifactLocation: {
                                        uri: path.relative(projectPath, issue.file)
                                    },
                                    region: {
                                        startLine: issue.line,
                                        startColumn: issue.column || 1
                                    }
                                }
                            }
                        ],
                        properties: {
                            category: issue.category,
                            remediation: issue.remediation,
                            references: issue.references
                        }
                    }))
                }
            ]
        };
        
        fs.writeFileSync(outputFile, JSON.stringify(sarif, null, 2));
    }

    private async generateJsonReport(scanResult: ScanResult, outputFile: string): Promise<void> {
        fs.writeFileSync(outputFile, JSON.stringify(scanResult, null, 2));
    }

    private generateSarifRules(issues: Issue[]): any[] {
        const uniqueRules = new Map<string, Issue>();
        
        issues.forEach(issue => {
            if (!uniqueRules.has(issue.rule)) {
                uniqueRules.set(issue.rule, issue);
            }
        });
        
        return Array.from(uniqueRules.values()).map(issue => ({
            id: issue.rule,
            name: issue.rule,
            shortDescription: {
                text: issue.message
            },
            fullDescription: {
                text: issue.description
            },
            defaultConfiguration: {
                level: this.mapSeverityToSarifLevel(issue.severity)
            },
            helpUri: issue.references?.[0]?.url,
            properties: {
                category: issue.category,
                tags: [issue.category, issue.severity]
            }
        }));
    }

    private mapSeverityToSarifLevel(severity: string): string {
        switch (severity) {
            case 'critical':
            case 'high':
                return 'error';
            case 'medium':
                return 'warning';
            case 'low':
            case 'info':
                return 'note';
            default:
                return 'warning';
        }
    }

    private groupIssuesByCategory(issues: Issue[]): Map<string, Issue[]> {
        const grouped = new Map<string, Issue[]>();
        
        issues.forEach(issue => {
            if (!grouped.has(issue.category)) {
                grouped.set(issue.category, []);
            }
            grouped.get(issue.category)!.push(issue);
        });
        
        return grouped;
    }

    private getSeverityCounts(issues: Issue[]): Record<string, number> {
        const counts = { critical: 0, high: 0, medium: 0, low: 0, info: 0 };
        
        issues.forEach(issue => {
            if (counts.hasOwnProperty(issue.severity)) {
                counts[issue.severity as keyof typeof counts]++;
            }
        });
        
        return counts;
    }

    private getSeverityWeight(severity: string): number {
        switch (severity) {
            case 'critical': return 5;
            case 'high': return 4;
            case 'medium': return 3;
            case 'low': return 2;
            case 'info': return 1;
            default: return 0;
        }
    }

    private getSeverityIcon(severity: string): string {
        switch (severity) {
            case 'critical': return 'üî¥';
            case 'high': return 'üü†';
            case 'medium': return 'üü°';
            case 'low': return 'üîµ';
            case 'info': return '‚ö™';
            default: return '‚ö™';
        }
    }

    private getCategoryIcon(category: string): string {
        switch (category) {
            case 'security': return 'üîí';
            case 'oss': return 'üì¶';
            case 'secrets': return 'üîë';
            case 'concurrency': return 'üîÄ';
            case 'tests': return 'üß™';
            case 'style': return 'üé®';
            default: return 'üìù';
        }
    }

    private getScoreDescription(score: number): string {
        if (score >= 90) return 'üü¢ **Excellent** - Your code is production-ready with minimal issues.';
        if (score >= 80) return 'üü° **Good** - Your code is mostly ready with some minor improvements needed.';
        if (score >= 70) return 'üü† **Fair** - Several issues need attention before production deployment.';
        if (score >= 60) return 'üî¥ **Poor** - Significant issues must be resolved before production.';
        return 'üö® **Critical** - Major issues present. Do not deploy to production.';
    }

    private capitalize(str: string): string {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
}